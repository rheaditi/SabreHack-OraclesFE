import JustEngine from '../JustEngine';
import AATLookupTable from './AATLookupTable';
import AATStateMachine from './AATStateMachine';

let VERTICAL_ONLY = 0x8000;
let REVERSE_DIRECTION = 0x4000;
let HORIZONTAL_AND_VERTICAL = 0x2000;
let SUBTABLE_TYPE_MASK = 0x0007;

let SET_MARK = 0x8000;
let MARK_CATEGORY = 0x3F80;
let CURRENT_CATEGORY = 0x007F;

const UNCONSTRAINED = 0x1000;
let JUST_PRIORITY = 0x000F;

class AATJustEngine extends JustEngine {
  categorizeGlyphs(glyphs, subtable) {
    let categories = glyphs.map(g => 0);
    if (!subtable.classTable) { return categories; }
    
    let stateMachine = new AATStateMachine(subtable.classTable.stateTable);
    let reverse = !!(subtable.coverage & REVERSE_DIRECTION);
    let markedIndex = -1;
    
    stateMachine.process(glyphs, reverse, (glyph, entry, index) => {      
      if (entry.flags & SET_MARK) {
        markedIndex = index;
      }
        
      let markCategory = entry.flags & MARK_CATEGORY;
      if (markCategory) {
        categories[markedIndex] = markCategory;
      }
        
      let currentCategory = entry.flags & CURRENT_CATEGORY;
      if (currentCategory) {
        return categories[index] = currentCategory;
      }
    });
        
    return categories;
  }
    
  factor(glyphs, gap) {
    let subtable = this.font.just.horizontal;
    if (!subtable) { return super.factor(); }
      
    let dir = gap > 0 ? 'Grow' : 'Shrink';
    let dirl = dir.toLowerCase();
    
    let lookupTable = new AATLookupTable(subtable.widthDeltaClusters);
    let categories = this.categorizeGlyphs(glyphs, subtable);
    this.categories = categories; // for postprocess method
          
    let factors = [];
    for (let index = 0; index < glyphs.length; index++) {
      let glyph = glyphs[index];
      let cluster = lookupTable.lookup(glyph.id);
      if (!cluster) {
        throw new Error(`Missing cluster for glyph: ${glyph.id}`);
      }
              
      let record = null;
      for (let i = 0; i < cluster.length; i++) {
        let wdr = cluster[i];
        if (wdr.justClass === categories[index]) {
          record = wdr;
          break;
        }
      }
          
      if (!record) {
        throw new Error(`Missing record for justClass: ${categories[index]}`);
      }
          
      let flags = record[`${dirl}Flags`];
      factors.push({
        before: record[`before${dir}Limit`],
        after: record[`after${dir}Limit`],
        priority: flags & JUST_PRIORITY,
        unconstrained: !!(flags & UNCONSTRAINED)
      });
    }
     
    if (glyphs[glyphs.length - 1].codePoints[0] === 32) {
      factors[factors.length - 1].before = 0;
      
      if (factors.length > 1) {
        factors[factors.length - 2].after = 0;
      }
    }
        
    factors[0].before = 0;
    factors[factors.length - 1].after = 0;
    
    return factors;
  }
  
  // TODO: also happens when line is not justified, e.g. if loose tracking is applied
  postprocess(glyphs, advances, distances) {
    let subtable = this.font.just.horizontal;
    let pc = subtable && subtable.postCompensationTable;
    if (!pc) { return super.postprocess(); }
    
    let lookupTable = new AATLookupTable(pc.lookupTable);
    let changed = false;
    for (let index = 0; index < glyphs.length; index++) {
      let glyph = glyphs[index];
      let actions = lookupTable.lookup(glyph.id);
      if (!actions) { continue; }
      
      let action = null;
      for (let i = 0; i < actions.length; i++) {
        let a = actions[i];
        if (a.actionClass === this.categories[index]) {
          action = a;
          break;
        }
      }
      
      switch (action.actionType) {
        case 0: // Decomposition action
          // check limits
          let dist = distances[index] / 18;
          if (dist < action.actionData.lowerLimit || dist > action.actionData.upperLimit) {
            changed = true;
            console.log('decompose');
            // TODO: Order field. Not exactly sure what it is for
            let { codePoints } = glyphs[index];
            let replacementGlyphs = action.actionData.glyphs.map((gid, i) => this.font.getGlyph(gid, [codePoints[i]]));
            glyphs.splice(index, 1, ...replacementGlyphs);
          }
          break;
            
        case 1: // Unconditional Add Glyph Action
          if (distances[index] > 0) {
            console.log('add');
            changed = true;
            var addGlyph = this.font.getGlyph(action.actionData.addGlyph);
            glyphs.splice(index + 1, 0, addGlyph);
          }
          break;
          
        case 2: // Conditional Add Glyph Action
          dist = distances[index] / 18;
          if (dist > 0) {
            if (dist > action.actionData.substThreshold) {
              console.log('subst');
              changed = true;
              glyphs[index] = this.font.getGlyph(action.actionData.substGlyph, glyphs[index].codePoints);
            }
            
            if (action.actionData.addGlyph !== 0xffff) {
              console.log('add');
              changed = true;
              var addGlyph = this.font.getGlyph(action.actionData.addGlyph);
              glyphs.splice(index + 1, 0, addGlyph);
            }
          }
          break;
              
        // Stretch and Ductile actions are not supported.
              
        case 5: // Repeated Add Glyph Action
          dist = distances[index] / 18;
          if (dist > 0) {
            var addGlyph = this.font.getGlyph(action.actionData.glyph);
            while (dist > addGlyph.advanceWidth) {
              glyphs.splice(index + 1, 0, addGlyph);
              console.log('add');
            }
          }
          break;
      }
    }
              
            // throw new Error 'TODO: repeated glyph add action'
      
    return changed;
  }
}
    
export default AATJustEngine;
